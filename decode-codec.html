<html>
<head>
<style>
.error { 
	color: red; 
	}
</style>
<title>Codec string decoder</title>

</head>


<body>
<h1>Codec string decoder</h1>

<p>Enter string: codecs="<input type="text" id="param"/>"
<button type="button" onclick="checkCodec()">Decode</button>
</p>
<div id="results"/>

<script src="./sscanf-func.js" type="text/javascript"></script> 


<script type="text/javascript">

const BREAK="<br>"


class BitList {
	bytes=[]
	
	push(b) {this.bytes.push(b & 0xFF)}
	
	bitset(bitNo) {
		if (bitNo<=0 || bitNo>(this.bytes.length*8))
			return false;
		let idx=this.bytes.length-Math.floor((bitNo-1)/8)-1
		let bit=bitNo%8
		if (bit==0) bit=8
			
		return (this.bytes[idx] & 1<<(bit-1))?true:false
	}
	
	pointers(bitNo) {
		let idx=this.bytes.length-Math.floor((bitNo-1)/8)-1
		let bit=bitNo%8
		if (bit==0) bit=8
		return "<i>"+bitNo+"="+idx+":"+bit+"</i>"+BREAK
	}
	toString() {
		let i=0, res=""
		while (i<this.bytes.length) {
			let comp=this.bytes[i++].toString(16)
			res+=((comp.length==1)?"0":"")+comp
		}
		return res
	}
}

function err(str) {
	return "<span class=\"error\">"+str+"</span>"
}

function bitSet32(val, bit) {
    // bit  3          2         1
	//      10987654321098765432109876543210	
	if (bit <0 || bit >31) return false
	return (val & Math.pow(2, bit))
}

function HEVCprofile(general_profile_idc, cap, gopocf) {
	if (general_profile_idc==1 || bitSet32(cap,1))
		return "Main (1)"
	
	if (general_profile_idc==2 || bitSet32(cap,2))
		return "Main 10 "+(gopocf?"Still Picture ":"")+"(2)"
	
	if (general_profile_idc==3 || bitSet32(cap,3))	
		return "Main Still Picture (3)"
		
	if (general_profile_idc==4 || bitSet32(cap,4))
		return "Range Extensions (4)"

	if (general_profile_idc==5 || bitSet32(cap,5))
		return "High Throughput (5)"
	
	if (general_profile_idc==9 || bitSet32(cap,9))
		return "Screen Content Coding (9)"

	if (general_profile_idc==11 || bitSet32(cap,11))
		return "High Throughput Screen Content Coding (11)"
	
	return err("unknown")

}
function decodeHEVC(val) {
	var parts=val.split(".")

	if (parts.length<5) 
		return err("HEVC codec requires at least 5 parts")+BREAK

	let argErr="", res=""		
	
	if (!hexDigits(parts[2]))
		argErr+=err("general_profile_compatibility_flag not expressed in hexadecimal ("+parts[2]+")")+BREAK
 
	let general_profile_compatibility_flag=sscanf(parts[2], "%x")	
	let general_profile_idc=-1, general_profile_space=-1
	
	if (parts[1][0]=="A" || parts[1][0]=="B" || parts[1][0]=="C") {
		let gp=sscanf(parts[1], "%c%d")
		switch (gp[0].toUpperCase()) {
			case "A": general_profile_space=1; break
			case "B": general_profile_space=2; break
			case "C": general_profile_space=3; break
		}
		general_profile_idc=gp[1]
	}
	else {
		general_profile_space=0
		general_profile_idc=sscanf(parts[1], "%d")
	}
 
	// process the constraints as we need to extract the general_one_picture_only_constraint_flag

	let constraintFlags=new BitList()
	let i=4, constraints="", general_one_picture_only_constraint_flag=0	
	while (i<10) {
		let bFlags=0
		if (parts[i]) {
			if (!hexDigits(parts[i])) 
				argErr+=err("constraint flags not specified in hexadecimal ("+parts[i]+")")+BREAK
			else
				bFlags=sscanf(parts[i].toLowerCase(), "%x")
		}
		constraintFlags.push(bFlags)
		i++
	}	

	if (argErr.length)
		return argErr

	constraints+="<i>constraintFlags="+ constraintFlags.toString() +"</i>"+BREAK
	
	let general_progressive_source_flag=constraintFlags.bitset(48),
	    general_interlaced_source_flag=constraintFlags.bitset(47)
			
	if (general_progressive_source_flag && !general_interlaced_source_flag)
		constraints+="scan=progressive"
	else if (!general_progressive_source_flag && general_interlaced_source_flag)
		constraints+="scan=interlaced"
	else if (general_progressive_source_flag && general_interlaced_source_flag)
		constraints+="scan=source_scan_type in SEI"
	else 
		constraints+=err("scan=unknown or unspecified")
	constraints+=BREAK;
	
	constraints+="general_non_packed_constraint_flag="+(constraintFlags.bitset(46)?"1":"0")+BREAK
	constraints+="general_frame_only_constraint_flag="+(constraintFlags.bitset(45)?"1":"0")+BREAK
	
	if (general_profile_idc==4 || bitSet32(general_profile_compatibility_flag, 4) ||
	    general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
	    general_profile_idc==6 || bitSet32(general_profile_compatibility_flag, 6) ||
	    general_profile_idc==7 || bitSet32(general_profile_compatibility_flag, 7) ||
	    general_profile_idc==8 || bitSet32(general_profile_compatibility_flag, 8) ||
	    general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
	    general_profile_idc==10 || bitSet32(general_profile_compatibility_flag, 10) ||
	    general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11) ) {
			
		constraints+="general_max_12bit_constraint_flag="+(constraintFlags.bitset(44)?"1":"0")+BREAK
		constraints+="general_max_10bit_constraint_flag="+(constraintFlags.bitset(43)?"1":"0")+BREAK
		constraints+="general_max_8bit_constraint_flag="+(constraintFlags.bitset(42)?"1":"0")+BREAK
		constraints+="general_max_422chroma_constraint_flag="+(constraintFlags.bitset(41)?"1":"0")+BREAK
		constraints+="general_max_420chroma_constraint_flag="+(constraintFlags.bitset(40)?"1":"0")+BREAK
		constraints+="general_max_monochrome_constraint_flag="+(constraintFlags.bitset(39)?"1":"0")+BREAK
		constraints+="general_intra_constraint_flag="+(constraintFlags.bitset(38)?"1":"0")+BREAK
		constraints+="general_one_picture_only_constraint_flag="+(constraintFlags.bitset(37)?"1":"0")+BREAK
		general_one_picture_only_constraint_flag=constraintFlags.bitset(37)
		constraints+="general_lower_bit_rate_constraint_flag="+(constraintFlags.bitset(36)?"1":"0")+BREAK
		
		if (general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
			general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
			general_profile_idc==10 || bitSet32(general_profile_compatibility_flag, 10) ||
			general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11)) {
			
			constraints+="general_max_12bit_constraint_flag="+(constraintFlags.bitset(35)?"1":"0")+BREAK
			// general_reserved_zero_33bits
		}
		else {
			// general_reserved_zero_34bits
		}
	}
	else if (general_profile_idc==2 || bitSet32(general_profile_compatibility_flag, 2)) {
	
		// general_reserved_zero_7bits
		constraints+="general_one_picture_only_constraint_flag="+(constraintFlags.bitset(37)?"1":"0")+BREAK
		general_one_picture_only_constraint_flag=constraintFlags.bitset(37)
		//general_reserved_zero_35bits
	}
	else {
		// general_reserved_zero_43bits
	}
	
	if (general_profile_idc==1 || bitSet32(general_profile_compatibility_flag, 1) ||
	    general_profile_idc==2 || bitSet32(general_profile_compatibility_flag, 2) ||
	    general_profile_idc==3 || bitSet32(general_profile_compatibility_flag, 3) ||
	    general_profile_idc==4 || bitSet32(general_profile_compatibility_flag, 4) ||
	    general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
	    general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
	    general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11) ) {
		
		constraints+="general_inbld_flag="+(constraintFlags.bitset(1)?"1":"0")+BREAK
	}
	else {
		// general_reserved_zero_bit
	}

	res+="general_profile_space="+(general_profile_space==-1?err(general_profile_space):general_profile_space)+BREAK
	res+="general_profile_idc="+HEVCprofile(general_profile_idc, general_profile_compatibility_flag, general_one_picture_only_constraint_flag)+BREAK
		
	let tier=sscanf(parts[3], "%c%d")
	switch (tier[0].toUpperCase()) {
		case "L": res+="Main Tier (L)"; break
		case "H": res+="High Tier (H)"; break
		default: res+=err("unknown Tier ("+tier[0]+")"); break
	}
	res+=" "
	let lev=null
	switch (tier[1]) {
		case 30: lev="1"; break
		case 60: lev="2"; break
		case 63: lev="2.1"; break
		case 90: lev="3"; break
		case 93: lev="3.1"; break
		case 120: lev="4"; break
		case 123: lev="4.1"; break
		case 150: lev="5"; break
		case 153: lev="5.1"; break
		case 156: lev="5.2"; break
		case 180: lev="6"; break
		case 183: lev="6.1"; break
		case 186: lev="6.2"; break
		default: res+=err("unknown Level ("+tier[1]+")")
	}
	if (lev) res+="Level "+lev
	res+=BREAK
	


	
	
	return res+constraints
}

function hexDigits(str) {
	var i,rc=true;
	res=str.match(/[\da-fA-F]+/)
	return res?res==str:false;
}


function AVCconstraint(val, constraint) {
	// constraint 012345--
	// bit        76543210	
	if (constraint<0 || constraint>5) return false;
	return (val & Math.pow(2, 7-constraint))	
}
/**
 * https://blog.pearce.org.nz/2013/11/what-does-h264avc1-codecs-parameters.html
 * https://en.wikipedia.org/wiki/Advanced_Video_Coding
 **/
function decodeAVC(val) {
	var parts=val.split(".")
	let res=""
//	res+="[1]="+parts[0]+" [2]="+parts[1]+BREAK
	
	if (parts.length!=2)
		return err("invalid format")+BREAK
	
	if (parts[1].length!=6) 
		return err("invalid parameters length ("+parts[1].length+") - should be 6")+BREAK
	
	if (!hexDigits(parts[1])) 
		return err("parameters contains non-hex digits")+BREAK
		
	
	let prof=sscanf(parts[1], "%2x%2x%2x")	
	res+="profile_idc="+prof[0]+" constraint_set="+prof[1]+" level_idc="+prof[2]+BREAK
	
	res+="profile="
	switch (prof[0]) {
		case 66: res+=AVCconstraint(prof[1], 1)?"Constrained ":""+"Baseline"; break
		case 77: res+="Main"; break
		case 100: 
			if (AVCconstraint(prof[1], 4) && !AVCconstraint(prof[1], 5))
				res+="Progressive "
			if (AVCconstraint(prof[1], 4) && AVCconstraint(prof[1], 5))
				res+="Constrained "	
			res+="High"; break
		case 122: res+="High 4:2:2"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 110: res+="High 10"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 144: res+="High 4:4:4"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 88: res+="Extended"; break
		case 83: res+="Scalable "+AVCconstraint(prof[1], 5)?"Constrained ":""+"Base"; break
		case 86: res+="Scalable "
			if (AVCconstraint(prof[1], 5) && !AVCconstraint(prof[1], 3)) res+="Constrained "
			if (AVCconstraint(prof[1], 3) && !AVCconstraint(prof[1], 5)) res+="Intra "
			res+="High"; break
		case 118: res+="Multiview High"; break
		case 128: res+="Stereo High"; break
		case 134: res+="MFC High"; break
		case 135: res+="MFC Depth High"; break
		case 138: res+="Multiview Depth High High"; break
		case 139: res+="Enhanced Multiview Depth High High"; break
		default:
			res+=err("unknown")					
	}
	res+=" ("+prof[0].toString(16)+")"+BREAK
	
	res+="constraints="
	for (var i=0; i<=5; i++)
		res+=(AVCconstraint(prof[1], i)?i:"-")
	res+=BREAK
	
	res+="level="
	switch (prof[2]) {
		case 10: res+="1"; break
		case 11: res+=AVCconstraint(prof[1], 3)?"1b":"1.1"; break
		case 12: res+="1.2"; break
		case 13: res+="1.3"; break
		case 20: res+="2"; break
		case 21: res+="2.1"; break
		case 22: res+="2.2"; break
		case 30: res+="3"; break
		case 31: res+="3.1"; break
		case 32: res+="3.2"; break
		case 40: res+="4"; break
		case 41: res+="4.1"; break
		case 42: res+="4.2"; break
		case 50: res+="5"; break
		case 51: res+="5.1"; break
		case 52: res+="5.2"; break
		case 60: res+="6"; break
		case 61: res+="6.1"; break
		case 62: res+="6.2"; break
		default: res+=err("undefined");
	}
	res+=" ("+prof[2].toString(16)+")"+BREAK

	return res;
}


function decode(val) {

	var codec=(val.indexOf(".") == -1)?val:val.substr(0, val.indexOf("."))
	var res=""

	switch (codec.toLowerCase()) {
		case "hev1":
		case "hvc1":
			res="HEVC/H.265<br>"+decodeHEVC(val)
			break
		case "avc1":
			res="AVC/H.264<br>"+decodeAVC(val)
			break
		default:
			res=err("unsupported codec="+codec)
	}
	
	return res;
}

function checkCodec() {
	var val, res;
	
	val=document.getElementById("param").value;
	res=decode(val);
	document.getElementById("results").innerHTML="<hr><h2>Results</h2>"+BREAK+res;
}
</script>

</body>
</html>