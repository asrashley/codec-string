<html>
<head>
<style>
.error { 
	color: red; 
	}
</style>
<title>Codec string decoder</title>

</head>


<body>
<h1>Codec string decoder</h1>

<p>Enter string: codecs="<input type="text" id="param"/>"
<button type="button" onclick="checkCodec()">Decode</button>
</p>
<div id="results"/>

<script src="./sscanf-func.js" type="text/javascript"></script> 


<script type="text/javascript">

const BREAK="<br>"


class BitList {
	bytes=[]
	
	push(b) {this.bytes.push(b & 0xFF)}
	
	bitset(bitNo) {
		if (bitNo<=0 || bitNo>(this.bytes.length*8))
			return false;
		let idx=this.bytes.length-Math.floor((bitNo-1)/8)-1
		let bit=bitNo%8
		if (bit==0) bit=8
			
		return (this.bytes[idx] & 1<<(bit-1))?true:false
	}
	
	pointers(bitNo) {
		let idx=this.bytes.length-Math.floor((bitNo-1)/8)-1
		let bit=bitNo%8
		if (bit==0) bit=8
		return "<i>"+bitNo+"="+idx+":"+bit+"</i>"+BREAK
	}
	toString() {
		let i=0, res=""
		while (i<this.bytes.length) {
			let comp=this.bytes[i++].toString(16)
			res+=((comp.length==1)?"0":"")+comp
		}
		return res
	}
}

function err(str) {
	return "<span class=\"error\">"+str+"</span>"
}

function bitSet32(val, bit) {
    // bit  3          2         1
	//      10987654321098765432109876543210	
	if (bit <0 || bit >31) return false
	return (val & Math.pow(2, bit))
}


function hexDigits(str) {
	var i,rc=true;
	res=str.match(/[\da-fA-F]+/)
	return res?res==str:false;
}



function decodeHEVC(val) {

	function HEVCprofile(general_profile_idc, cap, gopocf) {
		if (general_profile_idc==1 || bitSet32(cap,1)) return "Main (1)"	
		if (general_profile_idc==2 || bitSet32(cap,2)) return "Main 10 "+(gopocf?"Still Picture ":"")+"(2)"		
		if (general_profile_idc==3 || bitSet32(cap,3)) return "Main Still Picture (3)"
		if (general_profile_idc==4 || bitSet32(cap,4)) return "Range Extensions (4)"
		if (general_profile_idc==5 || bitSet32(cap,5)) return "High Throughput (5)"
		if (general_profile_idc==9 || bitSet32(cap,9)) return "Screen Content Coding (9)"
		if (general_profile_idc==11 || bitSet32(cap,11)) return "High Throughput Screen Content Coding (11)"		
		return err("unknown")
	}

	var parts=val.split(".")

	if (parts.length<5) 
		return err("HEVC codec requires at least 5 parts")+BREAK

	let argErr="", res=""		
	
	if (!hexDigits(parts[2]))
		argErr+=err("general_profile_compatibility_flag not expressed in hexadecimal ("+parts[2]+")")+BREAK
 
	let general_profile_compatibility_flag=sscanf(parts[2], "%x")	
	let general_profile_idc=-1, general_profile_space=-1
	
	if (parts[1][0]=="A" || parts[1][0]=="B" || parts[1][0]=="C") {
		let gp=sscanf(parts[1], "%c%d")
		switch (gp[0].toUpperCase()) {
			case "A": general_profile_space=1; break
			case "B": general_profile_space=2; break
			case "C": general_profile_space=3; break
		}
		general_profile_idc=gp[1]
	}
	else {
		general_profile_space=0
		general_profile_idc=sscanf(parts[1], "%d")
	}
 
	// process the constraints as we need to extract the general_one_picture_only_constraint_flag

	let constraintFlags=new BitList()
	let i=4, constraints="", general_one_picture_only_constraint_flag=0	
	while (i<10) {
		let bFlags=0
		if (parts[i]) {
			if (!hexDigits(parts[i])) 
				argErr+=err("constraint flags not specified in hexadecimal ("+parts[i]+")")+BREAK
			else
				bFlags=sscanf(parts[i].toLowerCase(), "%x")
		}
		constraintFlags.push(bFlags)
		i++
	}	

	if (argErr.length)
		return argErr

	constraints+="<i>constraintFlags="+ constraintFlags.toString() +"</i>"+BREAK
	
	let general_progressive_source_flag=constraintFlags.bitset(48),
	    general_interlaced_source_flag=constraintFlags.bitset(47)
			
	if (general_progressive_source_flag && !general_interlaced_source_flag)
		constraints+="scan=progressive"
	else if (!general_progressive_source_flag && general_interlaced_source_flag)
		constraints+="scan=interlaced"
	else if (general_progressive_source_flag && general_interlaced_source_flag)
		constraints+="scan=source_scan_type in SEI"
	else 
		constraints+=err("scan=unknown or unspecified")
	constraints+=BREAK;
	
	constraints+="general_non_packed_constraint_flag="+(constraintFlags.bitset(46)?"1":"0")+BREAK
	constraints+="general_frame_only_constraint_flag="+(constraintFlags.bitset(45)?"1":"0")+BREAK
	
	if (general_profile_idc==4 || bitSet32(general_profile_compatibility_flag, 4) ||
	    general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
	    general_profile_idc==6 || bitSet32(general_profile_compatibility_flag, 6) ||
	    general_profile_idc==7 || bitSet32(general_profile_compatibility_flag, 7) ||
	    general_profile_idc==8 || bitSet32(general_profile_compatibility_flag, 8) ||
	    general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
	    general_profile_idc==10 || bitSet32(general_profile_compatibility_flag, 10) ||
	    general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11) ) {
			
		constraints+="general_max_12bit_constraint_flag="+(constraintFlags.bitset(44)?"1":"0")+BREAK
		constraints+="general_max_10bit_constraint_flag="+(constraintFlags.bitset(43)?"1":"0")+BREAK
		constraints+="general_max_8bit_constraint_flag="+(constraintFlags.bitset(42)?"1":"0")+BREAK
		constraints+="general_max_422chroma_constraint_flag="+(constraintFlags.bitset(41)?"1":"0")+BREAK
		constraints+="general_max_420chroma_constraint_flag="+(constraintFlags.bitset(40)?"1":"0")+BREAK
		constraints+="general_max_monochrome_constraint_flag="+(constraintFlags.bitset(39)?"1":"0")+BREAK
		constraints+="general_intra_constraint_flag="+(constraintFlags.bitset(38)?"1":"0")+BREAK
		constraints+="general_one_picture_only_constraint_flag="+(constraintFlags.bitset(37)?"1":"0")+BREAK
		general_one_picture_only_constraint_flag=constraintFlags.bitset(37)
		constraints+="general_lower_bit_rate_constraint_flag="+(constraintFlags.bitset(36)?"1":"0")+BREAK
		
		if (general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
			general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
			general_profile_idc==10 || bitSet32(general_profile_compatibility_flag, 10) ||
			general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11)) {
			
			constraints+="general_max_12bit_constraint_flag="+(constraintFlags.bitset(35)?"1":"0")+BREAK
			// general_reserved_zero_33bits
		}
		else {
			// general_reserved_zero_34bits
		}
	}
	else if (general_profile_idc==2 || bitSet32(general_profile_compatibility_flag, 2)) {
	
		// general_reserved_zero_7bits
		constraints+="general_one_picture_only_constraint_flag="+(constraintFlags.bitset(37)?"1":"0")+BREAK
		general_one_picture_only_constraint_flag=constraintFlags.bitset(37)
		//general_reserved_zero_35bits
	}
	else {
		// general_reserved_zero_43bits
	}
	
	if (general_profile_idc==1 || bitSet32(general_profile_compatibility_flag, 1) ||
	    general_profile_idc==2 || bitSet32(general_profile_compatibility_flag, 2) ||
	    general_profile_idc==3 || bitSet32(general_profile_compatibility_flag, 3) ||
	    general_profile_idc==4 || bitSet32(general_profile_compatibility_flag, 4) ||
	    general_profile_idc==5 || bitSet32(general_profile_compatibility_flag, 5) ||
	    general_profile_idc==9 || bitSet32(general_profile_compatibility_flag, 9) ||
	    general_profile_idc==11 || bitSet32(general_profile_compatibility_flag, 11) ) {
		
		constraints+="general_inbld_flag="+(constraintFlags.bitset(1)?"1":"0")+BREAK
	}
	else {
		// general_reserved_zero_bit
	}

	res+="general_profile_space="+(general_profile_space==-1?err(general_profile_space):general_profile_space)+BREAK
	res+="general_profile_idc="+HEVCprofile(general_profile_idc, general_profile_compatibility_flag, general_one_picture_only_constraint_flag)+BREAK
		
	let tier=sscanf(parts[3], "%c%d")
	switch (tier[0].toUpperCase()) {
		case "L": res+="Main Tier (L)"; break
		case "H": res+="High Tier (H)"; break
		default: res+=err("unknown Tier ("+tier[0]+")"); break
	}
	res+=" "
	let lev=null
	switch (tier[1]) {
		case 30: lev="1"; break
		case 60: lev="2"; break
		case 63: lev="2.1"; break
		case 90: lev="3"; break
		case 93: lev="3.1"; break
		case 120: lev="4"; break
		case 123: lev="4.1"; break
		case 150: lev="5"; break
		case 153: lev="5.1"; break
		case 156: lev="5.2"; break
		case 180: lev="6"; break
		case 183: lev="6.1"; break
		case 186: lev="6.2"; break
		default: res+=err("unknown Level ("+tier[1]+")")
	}
	if (lev) res+="Level "+lev
	res+=BREAK
	
	return res+constraints
}





/**
 * https://blog.pearce.org.nz/2013/11/what-does-h264avc1-codecs-parameters.html
 * https://en.wikipedia.org/wiki/Advanced_Video_Coding
 **/
function decodeAVC(val) {

	function AVCconstraint(val, constraint) {
		// constraint 012345--
		// bit        76543210	
		if (constraint<0 || constraint>5) return false;
		return (val & Math.pow(2, 7-constraint))	
	}

	var parts=val.split(".")
	let res=""
//	res+="[1]="+parts[0]+" [2]="+parts[1]+BREAK
	
	if (parts.length!=2)
		return err("invalid format")+BREAK
	
	if (parts[1].length!=6) 
		return err("invalid parameters length ("+parts[1].length+") - should be 6")+BREAK
	
	if (!hexDigits(parts[1])) 
		return err("parameters contains non-hex digits")+BREAK
		
	
	let prof=sscanf(parts[1], "%2x%2x%2x")	
	res+="profile_idc="+prof[0]+" constraint_set="+prof[1]+" level_idc="+prof[2]+BREAK
	
	res+="profile="
	switch (prof[0]) {
		case 66: res+=AVCconstraint(prof[1], 1)?"Constrained ":""+"Baseline"; break
		case 77: res+="Main"; break
		case 100: 
			if (AVCconstraint(prof[1], 4) && !AVCconstraint(prof[1], 5))
				res+="Progressive "
			if (AVCconstraint(prof[1], 4) && AVCconstraint(prof[1], 5))
				res+="Constrained "	
			res+="High"; break
		case 122: res+="High 4:2:2"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 110: res+="High 10"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 144: res+="High 4:4:4"+AVCconstraint(prof[1], 3)?" Intra":""; break
		case 88: res+="Extended"; break
		case 83: res+="Scalable "+AVCconstraint(prof[1], 5)?"Constrained ":""+"Base"; break
		case 86: res+="Scalable "
			if (AVCconstraint(prof[1], 5) && !AVCconstraint(prof[1], 3)) res+="Constrained "
			if (AVCconstraint(prof[1], 3) && !AVCconstraint(prof[1], 5)) res+="Intra "
			res+="High"; break
		case 118: res+="Multiview High"; break
		case 128: res+="Stereo High"; break
		case 134: res+="MFC High"; break
		case 135: res+="MFC Depth High"; break
		case 138: res+="Multiview Depth High High"; break
		case 139: res+="Enhanced Multiview Depth High High"; break
		default:
			res+=err("unknown")					
	}
	res+=" ("+prof[0].toString(16)+")"+BREAK
	
	res+="constraints="
	for (var i=0; i<=5; i++)
		res+=(AVCconstraint(prof[1], i)?i:"-")
	res+=BREAK
	
	res+="level="
	switch (prof[2]) {
		case 10: res+="1"; break
		case 11: res+=AVCconstraint(prof[1], 3)?"1b":"1.1"; break
		case 12: res+="1.2"; break
		case 13: res+="1.3"; break
		case 20: res+="2"; break
		case 21: res+="2.1"; break
		case 22: res+="2.2"; break
		case 30: res+="3"; break
		case 31: res+="3.1"; break
		case 32: res+="3.2"; break
		case 40: res+="4"; break
		case 41: res+="4.1"; break
		case 42: res+="4.2"; break
		case 50: res+="5"; break
		case 51: res+="5.1"; break
		case 52: res+="5.2"; break
		case 60: res+="6"; break
		case 61: res+="6.1"; break
		case 62: res+="6.2"; break
		default: res+=err("undefined");
	}
	res+=" ("+prof[2].toString(16)+")"+BREAK

	return res;
}

/* RFC6381 - https://tools.ietf.org/html/rfc6381
   When the first element of a value is 'mp4a' (indicating some kind of
   MPEG-4 audio), or 'mp4v' (indicating some kind of MPEG-4 part-2
   video), or 'mp4s' (indicating some kind of MPEG-4 Systems streams
   such as MPEG-4 BInary Format for Scenes (BIFS)), the second element
   is the hexadecimal representation of the MP4 Registration Authority
   ObjectTypeIndication (OTI), as specified in [MP4RA] and [MP41]
   (including amendments).  Note that [MP4RA] uses a leading "0x" with
   these values, which is omitted here and hence implied.

   One of the OTI values for 'mp4a' is 40 (identifying MPEG-4 audio).
   For this value, the third element identifies the audio
   ObjectTypeIndication (OTI) as defined in [MP4A] (including
   amendments), expressed as a decimal number.

   For example, AAC low complexity (AAC-LC) has the value 2, so a
   complete string for AAC-LC would be "mp4a.40.2".
   
   [MP4RA] - http://www.mp4ra.org
   [MP4A] - "Information technology--Coding of audio-visual objects -- Part 3: Audio", ISO/IEC 14496-3:2009.
   [MP41] - "Information technology--Coding of audio-visual objects -- Part 1: Systems", ISO/IEC 14496-1:2010.
  */


function decodeAAC(val) {
	var parts=val.split(".")
	let res=""
	if (parts.length<2)
		return err("invalid format")
	if (!hexDigits(parts[1]))
		return err("OTI must be expressed in hexadecimal")
	
	// https://wiki.whatwg.org/wiki/video_type_parameters#Audio_Codecs_3
	// https://cconcolato.github.io/media-mime-support/
	
	let MP4oti=sscanf(parts[1], "%x")
	switch (MP4oti[0]) {
		case 0x40: 
			res+="MPEG-4 AAC (40)"+BREAK; 
			if (parts[2]) {
				let aacMode=sscanf(parts[2], "%d")
				let vals=[ {i:1, s:"Main"},
						   {i:2, s:"Low-Complexity AAC"},
						   {i:3, s:"SSR AAC"},
						   {i:4, s:"LTP AAC"},
						   {i:5, s:"High-Efficiency (SBR) AAC"},
						   {i:6, s:"MPEG-4 AAC-Scalable"},
						   {i:7, s:"MPEG-4 TWIN VQ"},
						   {i:8, s:"MPEG-4 CELP"},
						   {i:9, s:"MPEG-4 HVCX"},
						   {i:12, s:"MPEG-4 TTSI"},
						   {i:13, s:"MPEG-4 Main Synthetic"},
						   {i:14, s:"MPEG-4 Wavetable Synthetis"},
						   {i:15, s:"MPEG-4 General Midi"},
						   {i:16, s:"MPEG-4 ALGO_SYNTH_AUDIO_FX"},
						   {i:17, s:"MPEG-4 ER_AAC_LC"},
						   {i:19, s:"MPEG-4 ER_AAC_LTP"},
						   {i:20, s:"MPEG-4 ER_AAC_SCALABLE"},
						   {i:21, s:"MPEG-4 ER_TWINVQ"},
						   {i:22, s:"MPEG-4 ER_BSAC"},
						   {i:23, s:"MPEG-4 ER_AAC_LD"},
						   {i:24, s:"MPEG-4 ER_AAC_LD"},
						   {i:25, s:"MPEG-4 ER_HVXC"},
						   {i:26, s:"MPEG-4 ER_HILN"},
						   {i:27, s:"MPEG-4 ER_PARAMETRIC"},
						   {i:28, s:"MPEG-4 SSC"},
						   {i:29, s:"MPEG-4 AAC_PS"},
						   {i:32, s:"MPEG-4 LAYER1"},
						   {i:33, s:"MPEG-4 LAYER2"},
						   {i:34, s:"MPEG-4 LAYER3"},
						   {i:35, s:"MPEG-4 DST"},
						   {i:36, s:"MPEG-4 ALS"}
							]		
				const found=vals.find(elem => aacMode[0]==elem.i)
				res+=(found)?(found.s+" ("+found.i+")"):err("invalid AAC OTI ("+aacMode[0]+")")
				res+=BREAK
			}			
			break
		case 0x66: res+="MPEG-2 AAC Main Profile (66)"; break
		case 0x67: res+="MPEG-2 AAC Low Complexity Profile (67)"; break
		case 0x68: res+="MPEG-2 AAC Scalable Sampling Rate Profile (68)"; break
		case 0x69: res+="MPEG-2 Audio Part 3 (69)"; break
		case 0x6b: res+="MPEG-1 Part 3 (6B)"; break
		default:
			res+=err("invalid MP4 OTI ("+MP4oti.toString(16)+")")
	}
	res+=BREAK
	return res
}


function decode(val) {

	var codec=(val.indexOf(".") == -1)?val:val.substr(0, val.indexOf("."))
	var res=""

	switch (codec.toLowerCase()) {
		case "hev1":
		case "hvc1":
			res="HEVC/H.265"+BREAK+decodeHEVC(val)
			break
		case "avc3":
		case "avc1":
			res="AVC/H.264"+BREAK+decodeAVC(val)
			break
		case "mp4a":
			res="AAC"+BREAK+decodeAAC(val)
			break
		case "ec-3":
			res="Enhanced AC-3"+BREAK
			break
		default:
			res=err("unsupported codec="+codec)
	}
	
	return res;
}

function checkCodec() {
	var val, res;
	
	val=document.getElementById("param").value;
	res=decode(val);
	document.getElementById("results").innerHTML="<hr><h2>Results</h2>"+BREAK+res;
}
</script>

</body>
</html>